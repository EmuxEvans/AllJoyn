<!doctype HTML>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>AllJoyn开源教程</title>
<style>
body {
color: #333;
font-family: sans-serif;
font-size: 12pt;
line-height: 170%;
padding: 0 30px 0 270px;
}

header .banner {
margin: 0 0 1em 0;
}

header .banner, nav .banner {
color: #777;
font-size: 10pt;
font-weight: bold;
}

header h1 {
background: #0c3;
border-radius: 4px;
color: #fff;
font-size: 24pt;
margin: 0;
padding: 1.2em 0;
text-align: center;
}

nav {
font-size: 10pt;
overflow-x: hidden;
overflow-y: auto;
position: fixed;
top: 0;
left: 0;
bottom: 0;
width: 240px;
}

nav .menubar {
border-bottom: solid 1px #ccc;
display: none;
height: 48px;
line-height: 48px;
padding: 0 10px;
}

nav .button {
background: #777;
border: 1px solid #333;
color: #fff;
font-size: 10pt;
font-weight: bold;
padding: 8px;
border-radius: 4px;
}

nav ul {
padding: 0 0 0 10px;
}

nav ul a {
color: #333;
text-decoration: none;
}

nav ul a:hover {
text-decoration: underline;
}

nav li {
line-height: 180%;
list-style: none;
margin: 0;
padding: 0;
}

nav .level2 {
font-size: 11pt;
font-weight: bold;
}

nav .level3 {
padding-left: 1em;
}

nav .level3:before { 
content: "» ";
}

nav .level4 {
padding-left: 2em;
}

nav .level4:before {
content: "› ";
}

article h2 {
border-bottom: dotted 1px #777;
font-size: 12pt;
line-height: 100%;
margin: 4em 0 1em 0;
padding: 0 0 0.3em 0;
}

article h3 {
font-size: 12pt;
line-height: 100%;
margin: 2em 0 1em 0;
padding: 0;
}

article h4 {
font-size: 12pt;
font-style:italic;
font-weight: normal;
line-height: 100%;
margin: 1.2em 0 1em 0;
padding: 0;
}

article p {
margin: 1em 0;
}

article p code {
background: #eee;
border: 1px solid #ccc;
}

article p strong {
color: #f00;
}

article pre {
background: #eee;
border-left: solid 2px #3c0;
font-size: 10pt;
margin: 1em 0;
padding: 0 0 0 1em;
overflow-x: auto;
overflow-y: padding;
}

article blockquote {
background: #fff;
border: dashed 1px #777;
border-left: solid 2px #777;
color: #000;
margin: 0;
padding: 0 0 0 1em;
}

article ul, article ol {
padding-left: 2em;
}

footer {
border-top: 1px solid #ccc;
font-size: 10pt;
margin-top: 4em;
}

@media (max-width: 768px) {

body {
padding: 0 10px 0 230px;
}

nav {
width: 230px;
}

}

@media (max-width: 480px) {

body {
padding: 64px 10px 0 10px;
}

header .banner {
display: none;
}

nav {
position: absolute;
width: 100%;
}

nav .menubar {
display: block;
}

nav .banner {
float: right;
}

nav ul {
background: #fff;
display: none;
font-size: 14pt;
margin: 0;
padding: 0 0 0 8px;
}

nav .level2 {
font-size: 16pt;
font-weight: bold;
}

nav li {
line-height: 240%;
}

.index nav ul {
display: block;
}

.index article {
display: none;
}

}
</style>
<script>
  (function (tags) {
    var i = 0, len = tags.length;

    for (; i < len; ++i) {
        document.createElement(tags[i]);
    }
  }([ 'header', 'nav', 'article', 'footer' ]));
</script>
</head>
<body>
<header>
<h1 id="alljoyn-">AllJoyn开源教程</h1>

</header>
<nav>
<div class="menubar">
<a class="button">&#9776;&nbsp;索引</a>
</div>
<ul>
<li class="level2"><a href="#1">Architecture</a></li><li class="level3"><a href="#1.1">Network Architecture</a></li><li class="level4"><a href="#1.1.1">Apps and Routers</a></li><li class="level4"><a href="#1.1.2">Transports</a></li><li class="level3"><a href="#1.2">Software Architecture</a></li><li class="level4"><a href="#1.2.1">AllJoyn Router</a></li><li class="level4"><a href="#1.2.2">AllJoyn Core Library</a></li><li class="level4"><a href="#1.2.3">AllJoyn Service Framework Library</a></li><li class="level4"><a href="#1.2.4">AllJoyn App Code</a></li><li class="level4"><a href="#1.2.5">Thin and Standard</a></li><li class="level3"><a href="#1.3">Programming Models</a></li><li class="level4"><a href="#1.3.1">AllSeen Core Framework</a></li><li class="level4"><a href="#1.3.2">Data-Driven API</a></li><li class="level2"><a href="#2">Core Framework</a></li><li class="level3"><a href="#2.1">Bus Attachment</a></li><li class="level3"><a href="#2.2">Advertisement and Discovery</a></li><li class="level3"><a href="#2.3">Session and Port</a></li><li class="level3"><a href="#2.4">BusObject</a></li><li class="level3"><a href="#2.5">Sessionless Signal</a></li><li class="level3"><a href="#2.6">Introspection</a></li><li class="level3"><a href="#2.7">Events and Actions</a></li><li class="level3"><a href="#2.8">Security</a></li><li class="level3"><a href="#2.9">Putting It All Together</a></li><li class="level3"><a href="#2.10">Learn more</a></li></ul>

</nav>
<article>
<h2 id="1">Architecture</h2>
<p><a href="http://37iot.com">37IOT物联网开发社区</a>是国内专业的物联网开发技术论坛，欢迎各位有趣之士进入共同进步。</p>
<h3 id="1.1">Network Architecture</h3>
<p>AllJoyn框架运行在本地网络上。它可以让设备和应用去公布和发现对方。这一节讲述网络架构和各种各样的AllJoyn组件之间的关系。</p>
<h4 id="1.1.1">Apps and Routers</h4>
<p>AllJoyn框架包含AllJoyn应用和AllJoyn路由(Routers)，或者简称为应用和路由。应用与路由通信和路由与应用通信。应用和其他应用只能够通过路由来通讯。</p>
<p>应用和路由可以在同一个物理设备或者不同的设备上。从AllJoyn的立场来看，这不重要。事实上，有3种拓扑结构：</p>
<ol>
<li><p>一个应用使用他自己的路由。在这种情况下，路由被称作“Bundled Router”，因为它和应用绑定在了一起。手机操作系统(Android和iOS)和桌面操作系统(Mac OS X和Windows)上的AllJoyn应用通常使用这种结构。</p>
</li>
<li><p>同一个设备上多个应用使用一个路由。在这种情况下。路由被称作“Standalone Router”并且它通常运行在一个后台/服务(backgroud/service)进程。在Linux系统中，普遍做法是AllJoyn路由运行在一个daemon进程中，其他的AllJoyn应用连接到独立的路由上。在同一个设备上让多个应用使用共同的Alljoyn路由，设备消耗更少的资源。</p>
</li>
<li><p>一个应用使用一个在不同的设备上的路由。嵌入式设备(使用精简版(Thin variant)，稍后阐述)典型的使用这种方式，因为嵌入式设备没有足够的CPU和Memory去运行AllJoyn路由。
<img src="https://allseenalliance.org/sites/default/files/developers/learn/apps-and-routers.png" alt="apps-and-routers"></p>
</li>
</ol>
<h4 id="1.1.2">Transports</h4>
<p>AllJoyn框架运行在本地网络上。目前它支持Wi-Fi、Ethernet、Serial和Power Line(PLC)，但是自从 AllJoyn software was written to be transport-agnostic并且 AllJoyn系统是一个进化的开源项目，将来可能会支持更多的传输。
此外，bridge software can be created to bridge the AllJoyn framework to other systems like Zigbee, Z-wave, or the cloud。事实上，一个工作团队正在为增加<a href="https://wiki.allseenalliance.org/gateway/gatewayagent">网关代理( Gateway Agent)</a>而工作。 </p>
<h3 id="1.2">Software Architecture</h3>
<p>AllJoyn网络包括AllJoyn应用和AllJoyn路由。
一个Alljoyn应用应该包含下列组件：</p>
<ul>
<li><a href="https://allseenalliance.org/developers/learn/architecture#alljoyn-app-code">AllJoyn App Code</a></li>
<li><a href="https://allseenalliance.org/developers/learn/architecture#alljoyn-service-frameworks-libraries">AllJoyn Service Frameworks Libraries</a></li>
<li><a href="https://allseenalliance.org/developers/learn/architecture#alljoyn-core-library">AllJoyn Core Library</a></li>
</ul>
<p>一个<a href="https://allseenalliance.org/developers/learn/architecture#alljoyn-router">AllJoyn路由</a>可以单独运行也可以和AllJoyn Core Library绑定在一起。</p>
<p><img src="https://allseenalliance.org/sites/default/files/developers/learn/alljoyn-software-architecture.png" alt="alljoyn-software-architecture"></p>
<h4 id="1.2.1">AllJoyn Router</h4>
<p>AllJoyn路由在AllJoyn Routers and Applications之间转发AllJoyn messages ，including between different transports.</p>
<h4 id="1.2.2">AllJoyn Core Library</h4>
<p>AllJoyn Core Library提供最底层的一套API去和AllJoyn Network交互。它提供了直接调用：</p>
<ul>
<li>发布和发现</li>
<li>创建会话</li>
<li>接口定义(方法、属性，信号)</li>
<li>创建和处理对象</li>
</ul>
<p>开发者使用这些API去实现AllJoyn服务框架或者私有的接口。
<a href="https://allseenalliance.org/developers/learn/core">Learn more about AllJoyn Core Frameworks. </a></p>
<h4 id="1.2.3">AllJoyn Service Framework Library</h4>
<p>AllJoyn服务框架库实现了一套共同的服务，比如管理、通知或者控制面板。通过使用共同的AllJoyn服务框架，应用和设备可以正确的交互去执行特定的功能。
服务框架被分成了以下AllSeen工作组(AllSeen Working Groups):</p>
<ul>
<li><a href="https://allseenalliance.org/developers/learn/base-services">Base Services</a></li>
</ul>
<blockquote>
<p><a href="https://allseenalliance.org/developers/learn/base-services/onboarding">管理(Onboarding).</a>Provide a consistent way to bring a new device onto the Wi-Fi network.</p>
<p><a href="https://allseenalliance.org/developers/learn/base-services/configuration">配置(Configuration)</a>. Allows one to configure certain attributes of an application/device, such as its friendly name.</p>
<p><a href="https://allseenalliance.org/developers/learn/base-services/notification">通知(Notifications)</a>. Allows text-based notifications to be sent and received by devices on the AllJoyn network. Also supports audio and images via URLs.</p>
<p><a href="https://allseenalliance.org/developers/learn/base-services/controlpanel">控制面板(Control Panel)</a>. Allows devices to advertise a virtual control panel to be controlled remotely.</p>
</blockquote>
<ul>
<li><a href="https://wiki.allseenalliance.org/">更多的服务框架(More Service Frameworks)</a>. More service frameworks are actively being developed by the AllSeen Working Groups.</li>
</ul>
<p>鼓励开发人员尽可能的使用AllJoyn服务框架(AllJoyn Service Framework)。如果一个存在的服务不可用，开发人员可以和AllSeen Alliance共同开发一个标准的服务。在某些情况下，使用私有的服务和接口更合情合理；然而，这些服务不能交互，没法充分利用设备和应用的Alljoyn生态系统。</p>
<h4 id="1.2.4">AllJoyn App Code</h4>
<p>这是AllJoyn应用的应用逻辑。无论是提供高等级功能的Alljoyn服务框架库(AllJoyn Service Frameworks Libraries)或者提供直接调用的AllJoyn核心API(AllJoyn Core APIs)的Alljoyn核心库(AllJoyn Core Library)都是可编程的。</p>
<h4 id="1.2.5">Thin and Standard</h4>
<p>AllJoyn framework提供了两个版本：</p>
<ul>
<li>标准的(Standard).为非嵌入式设备，比如Android,iOS,Linux。</li>
<li>精简的(Thin).为资源有限的嵌入式设备，比如Arduino,ThreadX,低内存Linux。</li>
</ul>
<p><img src="https://allseenalliance.org/sites/default/files/developers/learn/alljoyn-standard-and-thin.png" alt="alljoyn-standard-and-thin"></p>
<h3 id="1.3">Programming Models</h3>
<h4 id="1.3.1">AllSeen Core Framework</h4>
<p>典型的，编写应用会通过使用AllJoyn服务框架API(AllJoyn Service Framework APIs )以便应用能够和使用相同服务框架的设备兼容。只有采用AllJoyn服务框架的AllSeen工作组开发的应用程序会在AllSeen生态系统与其他应用程序和设备兼容。
如果一个应用程序想实现它自己的服务，它可以通过对AllJoyn核心API(AllJoyn Core APIs)直接编程。当你这样做的时候，建议遵循事件(Events)和行为(Actions)公约去在其他的AllJoyn设备间实现特定的交互。
应用可以同时使用服务框架(Service Framework)和核心API(Core APIs)。</p>
<h4 id="1.3.2">Data-Driven API</h4>
<p>AllJoyn的数据驱动的API(DDAPI)是一个AllJoyn核心框架(AllJoyn Core framework)的替代API。它是建立在AllJoyn核心API的顶部，是专门为物联网特别定制的用例。取代核心框架的服务导向(service-oriented)的范例，它使用发布/订阅(publish/subcribe)模式。</p>
<p>For more Information, go <a href="https://allseenalliance.org/developers/learn/ddapi">here</a>.</p>
<p><a href="https://allseenalliance.org/developers/learn/core/events-and-actions">Learn more about Events and Actions.</a></p>

<h2 id="2">Core Framework</h2>
<p>这一节介绍AllJoyn™核心概念(AllJoyn™ Core concepts)。建议任何人开发AllJoyn应用都能高层次的理解(A base high-level understanding)，即使应用只是使用AllJoyn服务框架。</p>
<p><a href="http://37iot.com">37IOT物联网开发社区</a>是国内专业的物联网开发技术论坛，欢迎各位有趣之士进入共同进步。</p>
<h3 id="2.1">Bus Attachment</h3>
<p>AllJoyn应用使用和与AllJoyn网络交互必须要在初始化一个AllJoyn总线附属对象(AllJoyn Bus Attachment object)并且将这个对象连接到AllJoyn路由(AllJoyn Router)后。 </p>
<h3 id="2.2">Advertisement and Discovery</h3>
<p>AllJoyn应用可以广告他的服务通过两种机制：About Announcements and Well-Known Name。根据现有的传输(transports)，AllJoyn框架将使用不同的机制来确保应用程序可以由其他AllJoyn应用发现。 对于基于IP的传输，使用mDNS和多路广播与广播UDP包的组合。</p>
<p><strong>About Announcements</strong> 是被推荐使用的广告机制。它提供了通用的的方法去广播一组一致的应用感兴趣的元数据，如，模型，支持的接口，图形化的图标，以及更多。</p>
<p><strong>Well-Known Name</strong> 对于应用去公布和发现对方是一种更底层的机制。它是About Announcements使用的机制。推荐应用使用About Announcements机制，除非这里对这种低等级(lower-level)的功能有特别的需要。</p>
<p>在这两种情况下，发现的进程返回一个Alljoyn应用通过独特的名称来区别的列表。这个值用于随后创建进一步的通信会话。</p>
<p><a href="https://allseenalliance.org/developers/learn/core/about-announcement">Learn more about About Announcements. </a></p>
<h3 id="2.3">Session and Port</h3>
<p>AllJoyn框架负责创建不同AllJoyn应用之间的连接。通常，一个应用会提供一个服务通过About公告(About Announcements)来广告自己。远程应用发现这个应用(和他的UniqueName)，可以创建一个会话，这个过程称作JoinSession。该应用提供的服务有接受或者拒绝JoinSession请求的选项。</p>
<p>会话可以是point-to-point或者multi-point。point-to-point会话容许one-to-one连接，而multi-point容许一组设备/应用在同一个会话中交流。</p>
<p>会话是在一个特定的端口创建。不同的端口容许各种各样的point-to-point和multi-point连接的拓扑结构。在下面的图中，左边，A和B都会point-to-point连接到S的端口1上。右边，A,B,C和S都连接在S的端口2的multi-point会话上。
 <img src="https://allseenalliance.org/sites/default/files/developers/learn/alljoyn-core-sessions.png" alt="alljoyn-core-sessions"></p>
<h3 id="2.4">BusObject</h3>
<p>AllJoyn应用互相通讯通过BusObject抽象。这种抽象的地图(abstraction maps)和面向对象的编程思想一样，通过已经定义好的接口创建一个对象。通常，应用提供的服务创建一个BusObject。远程应用可以有效地远程打开这个BusObject然后在它上面调用方法，类似于远程过程调用(remote procedure call).</p>
<p>一个BusObject可以实现一组接口。每个接口清楚地定义了一组BusMethods,BusProperties, and BusSignals。BusMethods容许远程实体调用方法。BusProperties可以被获取和设置。BusSignals是应用提供的服务所发出的的信号。</p>
<p>BusObject附属在一个特别的总线路径上。这容许更大的灵活性，同一个对象可以为不同的目的而附属在不同的总线路径上。例如，如果应用为一个灶台实现了一个服务，StoveBurner BusObject能够连接到多个总线路径比如&#39;/range/left&#39;, &#39;/range/right&#39; 能够被创建去控制个别火炉燃烧器。</p>
<p>ProxyBusObject是远程应用创建的对象来获取BusObject权限。</p>
<p>总结，应用提供服务，实现了一个BusObject去公开访问他的服务。远程应用程序创建此应用的会话，并在一个特定的对象路径通过创建ProxyBusObject来连接到它的BusObject。然后调用BusMethods，访问BusProperties,接收BusSignals。
 <img src="https://allseenalliance.org/sites/default/files/developers/learn/alljoyn-core-busobject.png" alt="alljoyn-core-busobject"></p>
<h3 id="2.5">Sessionless Signal</h3>
<p>Sessionless Signal是用来无需创建一个会话来接收信号的机制。Under the hood,它使用Well-Known Name广告一个新的信号的存在。远程实体自动创建一个临时会话，接收到信号数据，然后会话会解除。AllJoyn Core APIs提供了这种抽象。</p>
<h3 id="2.6">Introspection</h3>
<p>Introspection建立在AllJoyn框架。APIs exist to easily introspect a remote AllJoyn application to discover its object paths and objects; its full interface including all methods; and parameters, properties, and signals. Via introspection, one can learn about the remote device and communicate with it without needing prior information about that device.</p>
<h3 id="2.7">Events and Actions</h3>
<p>事件和动作是一个应用程序来描述它的事件和行为的公约。通过为信号和方法添加简单的元数据描述，其他应用程序可以很容易地发现AllJoyn应用会发出什么样的行动和该应用可以接受哪些事件。这就容许其他应用在不同设备上一起动态连接事件和行为，去创建更加复杂的if-this-then-that交互。
<a href="https://allseenalliance.org/developers/learn/core/events-and-actions">Learn more about Events and Actions.</a></p>
<h3 id="2.8">Security</h3>
<p>AllJoyn security发生在应用层；这里不信任设备级。每个接口可以选择需要security。如果需要，认证发生在两个应用程序之间的方法被调用或接收信号的时候。多种认证机制支持：PIN code, PSK, or ECDSA (Elliptical Curve Digital Signature Algorithm)。一旦通过验证，这两个设备之间的所有信息都使用AES-128 CMM加密。</p>
<h3 id="2.9">Putting It All Together</h3>
<p>AllJoyn应用通过总线连接与AllJoyn框架交互。应用通过About公告广告他的服务，列出应用的元数据，包括支持的接口。UniqueName返回发现识别的应用。</p>
<p>当远程应用程序发现AllJoyn应用，它可以通过连接到一个特定的端口创建一个会话。point-to-point 和 multi-point 会议的支持。AllJoyn应用有权接受或拒绝连接请求。</p>
<p>会话创建之前，应用程序可以创建任意数量的总线对象，放在特定的对象路径。每个总线对象可以实现一组接口，由一组方法，属性，和信号定义。</p>
<p>会话创建后，远程应用程序通常会通过创建本地ProxyBusObject与BusObject交互，包括调用方法，获取和设置属性，接收信号。​
 <img src="https://allseenalliance.org/sites/default/files/developers/learn/alljoyn-core-components.png" alt="alljoyn-core-components"></p>
<p>在许多情况下，用户端发现，建立会话和代理对象的管理遵循一个简单的，在应用中常见的模式。标准核心库用<a href="https://allseenalliance.org/developers/develop/api-guide/core/observer/">Observer</a> class为这种情况提供了一个便利的API。The Observer class自动解析About公告，会话管理和为用户应用创建代理对象(Proxy object)</p>
<h3 id="2.10">Learn more</h3>
<ul>
<li><a href="https://allseenalliance.org/developers/learn/core/standard-core">Learn more about the AllJoyn Standard Core</a></li>
<li><a href="https://allseenalliance.org/developers/learn/core/thin-core">Learn more about the AllJoyn Thin Core</a></li>
<li><a href="https://allseenalliance.org/developers/learn/core/system-description">Learn more about the low-level details of the AllJoyn system</a></li>
</ul>

</article>
<footer>
<p>© 2014-2015 37IOT.com.</p>

</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48219354-1', 'nqdeng.github.io');
  ga('send', 'pageview');

  (function (nav) {
    var body = document.getElementsByTagName('body')[0];

    nav.addEventListener &&
    nav.addEventListener('click', function (e) {
      if (e.target.className == 'button') {
        body.className = !body.className ? 'index' : '';
      } else {
        body.className = '';
      }
    }, false);
  }(document.getElementsByTagName('nav')[0]));
</script>
</body>
</html>